#### 一、var的变量提升

​		var 指令的作用就是在当前作用域下声明了一个变量

​		**作用域：就是按照名称查找变量的一套规则/一个空间**

​			1、无论在哪个作用域中，var指令都会被提到该作用域代码的最前

​					console.log(a);		//输出underfined

​					var a=10;				

​					console.log(a);		//输出数字10

​		指令1：输出变量a

​		指令2：创造变量a并把数字10赋值给变量a

​		指令3：输出变量a

​		把上面的指令进行拆分：

​			指令1：输出变量a

​			指令2.1：创造变量a

​			指令2.2：把数字10赋值给变量a

​			指令3：输出变量a

​		指令提升：

​			指令2.1：创造变量a

​			指令1：输出变量a

​			指令2.2：把数字10赋值给变量a

​			指令3：输出变量a

​			代码如下：

​					var a；

​					console.log(a);

​					a=10;

​					console.log(a);

#### 二：函数的变量提升

​	无论在哪个作用域中，函数声明指令都会被提前到该作用域代码的最前，**函数声明指令会被提前到var指令之前**

​				comsole.log(a);  //输出变量underfined

​				console.log(add);	//输出函数add的内容

​				add();					//在控制台输出10

​				function add(){

​						console.log(9527);

​                }

​				var a=10;

​				指令1：输出变量a

​				指令2：输出变量add

​				指令3：执行变量add内存储的函数

​				指令4：声明变量add，并给变量add存储一个函数

​				指令5：创造变量a并把数字101赋值给变量a

​					指令拆分：

​						指令1：输出变量a

​				        指令2：输出变量add

​						指令3：执行变量add内存储的函数

​						指令4：声明变量add，并给变量add存储一个函数

​						指令5.1：创造变量a

​						指令5.2：把数字10赋值给变量a

​					指令提升：

​						指令4：声明变量add，并给变量add存储一个函数

​						指令5.1：创造变量a

​						指令1：输出变量a

​				        指令2：输出变量add

​						指令3：执行变量add内存储的函数

​						指令5.2：把数字10赋值给变量a

#### 三、let、const指令详解

###### 		1、let指令的块级作用域

​				var指令创造的变量只有 函数作用域，在控制流程内不会产生作用域，外面也可以访问到控制流程内部的变量

​				for(let i=0;i<10;i++){

​						console.log("hello"+i);

​				}

​				console.log(i)   //会报错

​				上面代码第一个console.log会执行，第二个会报错，原因是使用let指令创造的变量，存在块级作用域，控制流程内部用let指令定义的变量，在控制流程外部无法获取。

​				1.1、let指令的重复声明问题

​						如果我们已经使用var指令声明了一个变量，那么下方如果也出现了一个var指令声明了同一个名称的变量，那么下方var指令会被忽略。

​						如果某个变量已经用let指令声明，那么就不能再次使用let或是var声明；如果某个变量已经被var指令声明，那么就不能再次使用let声明。

​				1.2、let指令的临时死区

​							console.log(b);

​							let b=10;		//会报错，在没有初始化（声明）变量b之前，不可以访问变量b的数据

​							因为let指令没有变量提升，所以在浏览器在执行let指令之前，任何语句都无法使用该let指令所定义的变量

######  2、const指令（定义常量）

​		所谓常量就是不会变化的。

​		const声明和let声明非常类似，区别就是

​				2.1：const定义好一个值之后，不允许修改变量值；

​				2.2、初始化变量的时候就要赋值；

​				2.3、常量变量名尽量大写

##### 四、函数的闭包原理

​		1、js的垃圾回收原则：

​					JavaScript最常用的是标记清除：当变量进入环境（作用域则），则将变量标记为进入环境，当变量离开环境的时候，将其标记为离开环境、

​					垃圾收集器在运行时会给存储在内存中所有变量标记，然后去掉环境变量与被环境变量引用的变量，剩下的就是环境无法访问的变量，这些变量以及其占用的内容空间将被清理回收。

​		2、函数的闭包原理

​					函数内部的变量在函数外部是无法获取的，但是如果我们要获得函数内部的某个参数或是变量的值的话，我们可以用return方法来实现

​					function  foo(){

​							var     a="我是foo里面的a"；

​							return    a；

​					}

​					let      b=foo();

​					console.log(b);		//输出  “我是foo里面的a”

​		**函数可以通过作用域链互相关联起来，函数内部的变量都可以保存在函数作用域内，这种特效被称为闭包**